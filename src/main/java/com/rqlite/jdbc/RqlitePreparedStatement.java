package com.rqlite.jdbc;

import java.io.IOException;
import java.io.InputStream;
import java.io.Reader;
import java.math.BigDecimal;
import java.net.URL;
import java.sql.Array;
import java.sql.Blob;
import java.sql.Clob;
import java.sql.Date;
import java.sql.NClob;
import java.sql.ParameterMetaData;
import java.sql.PreparedStatement;
import java.sql.Ref;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.RowId;
import java.sql.SQLException;
import java.sql.SQLFeatureNotSupportedException;
import java.sql.SQLTimeoutException;
import java.sql.SQLXML;
import java.sql.Time;
import java.sql.Timestamp;
import java.sql.Types;
import java.time.ZonedDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.Base64;
import java.util.Calendar;
import java.util.List;

import com.rqlite.dto.ExecuteQueryRequestResults;
import com.rqlite.dto.QueryResults.Result;
import com.rqlite.dto.Statement.Parameter;

public class RqlitePreparedStatement extends RqliteStatement implements PreparedStatement {
  // Formatter for java.sql.Date (only date part)
  public static final DateTimeFormatter DATE_FORMATTER = DateTimeFormatter.ofPattern("yyyy-MM-dd");

  // Formatter for java.sql.Timestamp (date, time up to nanoseconds, and offset)
  public static final DateTimeFormatter TIMESTAMP_FORMATTER = DateTimeFormatter.ofPattern("yyyy-MM-dd'T'HH:mm:ss.SSSSSSSSSXXX");

  // Formatter for java.sql.Time
  public static final DateTimeFormatter TIME_FORMATTER = DateTimeFormatter.ofPattern(
      "HH:mm[:ss[.SSSSSSSSS]][XXX]"
  );

  private final String sql;
  private final ArrayList<Parameter> parameters;
  private final List<ArrayList<Parameter>> batch;

  public RqlitePreparedStatement(RqliteConnection rqliteConnection, String sql) {
    super(rqliteConnection);
    this.sql = sql;
    this.parameters = new ArrayList<>();
    this.batch = new ArrayList<>();
  }

  /**
   * Executes the SQL query in this {@code PreparedStatement} object
   * and returns the {@code ResultSet} object generated by the query.
   *
   * @return a {@code ResultSet} object that contains the data produced by the
   * query; never {@code null}
   * @throws SQLException        if a database access error occurs;
   *                             this method is called on a closed  {@code PreparedStatement} or the SQL
   *                             statement does not return a {@code ResultSet} object
   * @throws SQLTimeoutException when the driver has determined that the
   *                             timeout value that was specified by the {@code setQueryTimeout}
   *                             method has been exceeded and has at least attempted to cancel
   *                             the currently running {@code Statement}
   */
  @Override
  public ResultSet executeQuery() throws SQLException {
    checkOpen();
    checkSQLNullOrEmpty(sql);
    clearLastResults();
    lastResult = conn.query(com.rqlite.dto.Statement.newBuilder().setSql(sql).setParameters(parameters).build(), this);
    return lastResult;
  }

  /**
   * Executes the SQL statement in this {@code PreparedStatement} object,
   * which must be an SQL Data Manipulation Language (DML) statement, such as {@code INSERT}, {@code UPDATE} or
   * {@code DELETE}; or an SQL statement that returns nothing,
   * such as a DDL statement.
   *
   * @return either (1) the row count for SQL Data Manipulation Language (DML) statements
   * or (2) 0 for SQL statements that return nothing
   * @throws SQLException        if a database access error occurs;
   *                             this method is called on a closed  {@code PreparedStatement}
   *                             or the SQL statement returns a {@code ResultSet} object
   * @throws SQLTimeoutException when the driver has determined that the
   *                             timeout value that was specified by the {@code setQueryTimeout}
   *                             method has been exceeded and has at least attempted to cancel
   *                             the currently running {@code Statement}
   */
  @Override
  public int executeUpdate() throws SQLException {
    checkOpen();
    checkSQLNullOrEmpty(sql);
    clearLastResults();
    lastUpdateCount = conn.execute(com.rqlite.dto.Statement.newBuilder().setSql(sql).setParameters(parameters).build(), this);
    return lastUpdateCount;
  }

  /**
   * Sets the designated parameter to SQL {@code NULL}.
   *
   * <P><B>Note:</B> You must specify the parameter's SQL type.
   *
   * @param parameterIndex the first parameter is 1, the second is 2, ...
   * @param sqlType        the SQL type code defined in {@code java.sql.Types}
   * @throws SQLException                    if parameterIndex does not correspond to a parameter
   *                                         marker in the SQL statement; if a database access error occurs or
   *                                         this method is called on a closed {@code PreparedStatement}
   * @throws SQLFeatureNotSupportedException if {@code sqlType} is
   *                                         a {@code ARRAY}, {@code BLOB}, {@code CLOB},
   *                                         {@code DATALINK}, {@code JAVA_OBJECT}, {@code NCHAR},
   *                                         {@code NCLOB}, {@code NVARCHAR}, {@code LONGNVARCHAR},
   *                                         {@code REF}, {@code ROWID}, {@code SQLXML}
   *                                         or  {@code STRUCT} data type and the JDBC driver does not support
   *                                         this data type
   */
  @Override
  public void setNull(int parameterIndex, int sqlType) throws SQLException {
    setObject(parameterIndex, null);
  }

  /**
   * Sets the designated parameter to the given Java {@code boolean} value.
   * The driver converts this
   * to an SQL {@code BIT} or {@code BOOLEAN} value when it sends it to the database.
   *
   * @param parameterIndex the first parameter is 1, the second is 2, ...
   * @param x              the parameter value
   * @throws SQLException if parameterIndex does not correspond to a parameter
   *                      marker in the SQL statement;
   *                      if a database access error occurs or
   *                      this method is called on a closed {@code PreparedStatement}
   */
  @Override
  public void setBoolean(int parameterIndex, boolean x) throws SQLException {
    setObject(parameterIndex, x);
  }

  /**
   * Sets the designated parameter to the given Java {@code byte} value.
   * The driver converts this
   * to an SQL {@code TINYINT} value when it sends it to the database.
   *
   * @param parameterIndex the first parameter is 1, the second is 2, ...
   * @param x              the parameter value
   * @throws SQLException if parameterIndex does not correspond to a parameter
   *                      marker in the SQL statement; if a database access error occurs or
   *                      this method is called on a closed {@code PreparedStatement}
   */
  @Override
  public void setByte(int parameterIndex, byte x) throws SQLException {
    setObject(parameterIndex, Byte.toString(x));
  }

  /**
   * Sets the designated parameter to the given Java {@code short} value.
   * The driver converts this
   * to an SQL {@code SMALLINT} value when it sends it to the database.
   *
   * @param parameterIndex the first parameter is 1, the second is 2, ...
   * @param x              the parameter value
   * @throws SQLException if parameterIndex does not correspond to a parameter
   *                      marker in the SQL statement; if a database access error occurs or
   *                      this method is called on a closed {@code PreparedStatement}
   */
  @Override
  public void setShort(int parameterIndex, short x) throws SQLException {
    setObject(parameterIndex, x);
  }

  /**
   * Sets the designated parameter to the given Java {@code int} value.
   * The driver converts this
   * to an SQL {@code INTEGER} value when it sends it to the database.
   *
   * @param parameterIndex the first parameter is 1, the second is 2, ...
   * @param x              the parameter value
   * @throws SQLException if parameterIndex does not correspond to a parameter
   *                      marker in the SQL statement; if a database access error occurs or
   *                      this method is called on a closed {@code PreparedStatement}
   */
  @Override
  public void setInt(int parameterIndex, int x) throws SQLException {
    setObject(parameterIndex, x);
  }

  /**
   * Sets the designated parameter to the given Java {@code long} value.
   * The driver converts this
   * to an SQL {@code BIGINT} value when it sends it to the database.
   *
   * @param parameterIndex the first parameter is 1, the second is 2, ...
   * @param x              the parameter value
   * @throws SQLException if parameterIndex does not correspond to a parameter
   *                      marker in the SQL statement; if a database access error occurs or
   *                      this method is called on a closed {@code PreparedStatement}
   */
  @Override
  public void setLong(int parameterIndex, long x) throws SQLException {
    setObject(parameterIndex, x);
  }

  /**
   * Sets the designated parameter to the given Java {@code float} value.
   * The driver converts this
   * to an SQL {@code REAL} value when it sends it to the database.
   *
   * @param parameterIndex the first parameter is 1, the second is 2, ...
   * @param x              the parameter value
   * @throws SQLException if parameterIndex does not correspond to a parameter
   *                      marker in the SQL statement; if a database access error occurs or
   *                      this method is called on a closed {@code PreparedStatement}
   */
  @Override
  public void setFloat(int parameterIndex, float x) throws SQLException {
    setObject(parameterIndex, x);
  }

  /**
   * Sets the designated parameter to the given Java {@code double} value.
   * The driver converts this
   * to an SQL {@code DOUBLE} value when it sends it to the database.
   *
   * @param parameterIndex the first parameter is 1, the second is 2, ...
   * @param x              the parameter value
   * @throws SQLException if parameterIndex does not correspond to a parameter
   *                      marker in the SQL statement; if a database access error occurs or
   *                      this method is called on a closed {@code PreparedStatement}
   */
  @Override
  public void setDouble(int parameterIndex, double x) throws SQLException {
    setObject(parameterIndex, x);
  }

  /**
   * Sets the designated parameter to the given {@code java.math.BigDecimal} value.
   * The driver converts this to an SQL {@code NUMERIC} value when
   * it sends it to the database.
   *
   * @param parameterIndex the first parameter is 1, the second is 2, ...
   * @param x              the parameter value
   * @throws SQLException if parameterIndex does not correspond to a parameter
   *                      marker in the SQL statement; if a database access error occurs or
   *                      this method is called on a closed {@code PreparedStatement}
   */
  @Override
  public void setBigDecimal(int parameterIndex, BigDecimal x) throws SQLException {
    setObject(parameterIndex, x);
  }

  /**
   * Sets the designated parameter to the given Java {@code String} value.
   * The driver converts this
   * to an SQL {@code VARCHAR} or {@code LONGVARCHAR} value
   * (depending on the argument's
   * size relative to the driver's limits on {@code VARCHAR} values)
   * when it sends it to the database.
   *
   * @param parameterIndex the first parameter is 1, the second is 2, ...
   * @param x              the parameter value
   * @throws SQLException if parameterIndex does not correspond to a parameter
   *                      marker in the SQL statement; if a database access error occurs or
   *                      this method is called on a closed {@code PreparedStatement}
   */
  @Override
  public void setString(int parameterIndex, String x) throws SQLException {
    setObject(parameterIndex, x);
  }

  /**
   * Sets the designated parameter to the given Java array of bytes.  The driver converts
   * this to an SQL {@code VARBINARY} or {@code LONGVARBINARY}
   * (depending on the argument's size relative to the driver's limits on
   * {@code VARBINARY} values) when it sends it to the database.
   *
   * @param parameterIndex the first parameter is 1, the second is 2, ...
   * @param x              the parameter value
   * @throws SQLException if parameterIndex does not correspond to a parameter
   *                      marker in the SQL statement; if a database access error occurs or
   *                      this method is called on a closed {@code PreparedStatement}
   */
  @Override
  public void setBytes(int parameterIndex, byte[] x) throws SQLException {
    setObject(parameterIndex, Base64.getEncoder().encodeToString(x)); // TODO: I don't think this will work correctly and we may need to throw an exception and force HEX
  }

  /**
   * Sets the designated parameter to the given {@code java.sql.Date} value
   * using the default time zone of the virtual machine that is running
   * the application.
   * The driver converts this
   * to an SQL {@code DATE} value when it sends it to the database.
   *
   * @param parameterIndex the first parameter is 1, the second is 2, ...
   * @param x              the parameter value
   * @throws SQLException if parameterIndex does not correspond to a parameter
   *                      marker in the SQL statement; if a database access error occurs or
   *                      this method is called on a closed {@code PreparedStatement}
   */
  @Override
  public void setDate(int parameterIndex, Date x) throws SQLException {
    setObject(parameterIndex, DATE_FORMATTER.format(x.toLocalDate()));
  }

  /**
   * Sets the designated parameter to the given {@code java.sql.Time} value.
   * The driver converts this
   * to an SQL {@code TIME} value when it sends it to the database.
   *
   * @param parameterIndex the first parameter is 1, the second is 2, ...
   * @param x              the parameter value
   * @throws SQLException if parameterIndex does not correspond to a parameter
   *                      marker in the SQL statement; if a database access error occurs or
   *                      this method is called on a closed {@code PreparedStatement}
   */
  @Override
  public void setTime(int parameterIndex, Time x) throws SQLException {
    setObject(parameterIndex, TIME_FORMATTER.format(x.toLocalTime()));
  }

  /**
   * Sets the designated parameter to the given {@code java.sql.Timestamp} value.
   * The driver
   * converts this to an SQL {@code TIMESTAMP} value when it sends it to the
   * database.
   *
   * @param parameterIndex the first parameter is 1, the second is 2, ...
   * @param x              the parameter value
   * @throws SQLException if parameterIndex does not correspond to a parameter
   *                      marker in the SQL statement; if a database access error occurs or
   *                      this method is called on a closed {@code PreparedStatement}
   */
  @Override
  public void setTimestamp(int parameterIndex, Timestamp x) throws SQLException {
    setObject(parameterIndex, TIMESTAMP_FORMATTER.format(x.toLocalDateTime()));
  }

  /**
   * Sets the designated parameter to the given input stream, which will have
   * the specified number of bytes.
   * When a very large ASCII value is input to a {@code LONGVARCHAR}
   * parameter, it may be more practical to send it via a
   * {@code java.io.InputStream}. Data will be read from the stream
   * as needed until end-of-file is reached.  The JDBC driver will
   * do any necessary conversion from ASCII to the database char format.
   *
   * <P><B>Note:</B> This stream object can either be a standard
   * Java stream object or your own subclass that implements the
   * standard interface.
   *
   * @param parameterIndex the first parameter is 1, the second is 2, ...
   * @param x              the Java input stream that contains the ASCII parameter value
   * @param length         the number of bytes in the stream
   * @throws SQLException if parameterIndex does not correspond to a parameter
   *                      marker in the SQL statement; if a database access error occurs or
   *                      this method is called on a closed {@code PreparedStatement}
   */
  @Override
  public void setAsciiStream(int parameterIndex, InputStream x, int length) throws SQLException {
    throw new SQLFeatureNotSupportedException(RqliteResultSet.SQL_FEATURE_NOT_SUPPORTED);
  }

  /**
   * Sets the designated parameter to the given input stream, which
   * will have the specified number of bytes.
   * <p>
   * When a very large Unicode value is input to a {@code LONGVARCHAR}
   * parameter, it may be more practical to send it via a
   * {@code java.io.InputStream} object. The data will be read from the
   * stream as needed until end-of-file is reached.  The JDBC driver will
   * do any necessary conversion from Unicode to the database char format.
   * <p>
   * The byte format of the Unicode stream must be a Java UTF-8, as defined in the
   * Java Virtual Machine Specification.
   *
   * <P><B>Note:</B> This stream object can either be a standard
   * Java stream object or your own subclass that implements the
   * standard interface.
   *
   * @param parameterIndex the first parameter is 1, the second is 2, ...
   * @param x              a {@code java.io.InputStream} object that contains the
   *                       Unicode parameter value
   * @param length         the number of bytes in the stream
   * @throws SQLException                    if parameterIndex does not correspond to a parameter
   *                                         marker in the SQL statement; if a database access error occurs or
   *                                         this method is called on a closed {@code PreparedStatement}
   * @throws SQLFeatureNotSupportedException if the JDBC driver does not support
   *                                         this method
   * @deprecated Use {@code setCharacterStream}
   */
  @Override
  public void setUnicodeStream(int parameterIndex, InputStream x, int length) throws SQLException {
    throw new SQLFeatureNotSupportedException(RqliteResultSet.SQL_FEATURE_NOT_SUPPORTED);
  }

  /**
   * Sets the designated parameter to the given input stream, which will have
   * the specified number of bytes.
   * When a very large binary value is input to a {@code LONGVARBINARY}
   * parameter, it may be more practical to send it via a
   * {@code java.io.InputStream} object. The data will be read from the
   * stream as needed until end-of-file is reached.
   *
   * <P><B>Note:</B> This stream object can either be a standard
   * Java stream object or your own subclass that implements the
   * standard interface.
   *
   * @param parameterIndex the first parameter is 1, the second is 2, ...
   * @param x              the java input stream which contains the binary parameter value
   * @param length         the number of bytes in the stream
   * @throws SQLException if parameterIndex does not correspond to a parameter
   *                      marker in the SQL statement; if a database access error occurs or
   *                      this method is called on a closed {@code PreparedStatement}
   */
  @Override
  public void setBinaryStream(int parameterIndex, InputStream x, int length) throws SQLException {
    byte[] buf = new byte[length];
    try {
      x.read(buf, 0, length);
    } catch (IOException e) {
      throw new SQLException(e);
    }
    setObject(parameterIndex, Base64.getEncoder().encodeToString(buf)); // TODO: Same as setBytes
  }

  /**
   * Clears the current parameter values immediately.
   * <P>In general, parameter values remain in force for repeated use of a
   * statement. Setting a parameter value automatically clears its
   * previous value.  However, in some cases it is useful to immediately
   * release the resources used by the current parameter values; this can
   * be done by calling the method {@code clearParameters}.
   *
   * @throws SQLException if a database access error occurs or
   *                      this method is called on a closed {@code PreparedStatement}
   */
  @Override
  public void clearParameters() throws SQLException {
    checkOpen();
    parameters.clear();
  }

  /**
   * Sets the value of the designated parameter with the given object.
   * <p>
   * This method is similar to {@link #setObject(int parameterIndex,
   * Object x, int targetSqlType, int scaleOrLength)},
   * except that it assumes a scale of zero.
   *
   * @param parameterIndex the first parameter is 1, the second is 2, ...
   * @param parameterObject              the object containing the input parameter value
   * @param targetSqlType  the SQL type (as defined in java.sql.Types) to be
   *                       sent to the database
   * @throws SQLException                    if parameterIndex does not correspond to a parameter
   *                                         marker in the SQL statement; if a database access error occurs or this
   *                                         method is called on a closed PreparedStatement
   * @throws SQLFeatureNotSupportedException if
   *                                         the JDBC driver does not support the specified targetSqlType
   * @see Types
   */
  @Override
  public void setObject(int parameterIndex, Object parameterObject, int targetSqlType) throws SQLException {
    Object val;

    switch (targetSqlType) {
      case Types.BOOLEAN:
        if (parameterObject instanceof Boolean) {
          setBoolean(parameterIndex, (Boolean) parameterObject);
          break;
        } else if (parameterObject instanceof String) {
          setBoolean(parameterIndex, "true".equalsIgnoreCase((String) parameterObject) || !"0"
              .equalsIgnoreCase((String) parameterObject));
          break;
        } else if (parameterObject instanceof Number) {
          int intValue = ((Number) parameterObject).intValue();
          setBoolean(parameterIndex, intValue != 0);
          break;
        } else {
          throw new SQLException("Conversion from" + parameterObject.getClass().getName()
              + "to Types.Boolean is not Possible");
        }
      case Types.BIT:
      case Types.TINYINT:
      case Types.SMALLINT:
      case Types.INTEGER:
      case Types.BIGINT:
      case Types.REAL:
      case Types.FLOAT:
      case Types.DOUBLE:
      case Types.DECIMAL:
      case Types.NUMERIC:
        setNumericObject(parameterIndex, parameterObject, targetSqlType);
        break;
      case Types.CHAR:
      case Types.VARCHAR:
      case Types.LONGVARCHAR:
        setString(parameterIndex, parameterObject.toString());
        break;
      case Types.CLOB:
        if (parameterObject instanceof Clob) {
          setClob(parameterIndex, (Clob) parameterObject);
        } else {
          setString(parameterIndex, parameterObject.toString());
        }
        break;
      case Types.BINARY:
      case Types.VARBINARY:
      case Types.LONGVARBINARY:
      case Types.BLOB:
        if (parameterObject instanceof Blob) {
          setBlob(parameterIndex, (Blob) parameterObject);
        } else {
          setBytes(parameterIndex, (byte[]) parameterObject);
        }
        break;
      case Types.DATE:
      case Types.TIMESTAMP:
        java.util.Date parameterAsDate = (java.util.Date) parameterObject;
        switch (targetSqlType) {
          case Types.DATE:
            if (parameterAsDate instanceof Date) {
              setDate(parameterIndex, (Date) parameterAsDate);
            } else {
              setDate(parameterIndex, new Date(parameterAsDate.getTime()));
            }
            break;
          case Types.TIMESTAMP:
            if (parameterAsDate instanceof Timestamp) {
              setTimestamp(parameterIndex, (Timestamp) parameterAsDate);
            } else {
              setTimestamp(parameterIndex, new Timestamp(parameterAsDate.getTime()));
            }
            break;
        }
        break;
      case Types.TIME:
        if (parameterObject instanceof Timestamp timestamp) {
          setTime(parameterIndex, new Time(timestamp.getTime()));
        } else {
          setTime(parameterIndex, (Time) parameterObject);
        }
        break;
      default:
        throw new SQLFeatureNotSupportedException(RqliteResultSet.SQL_FEATURE_NOT_SUPPORTED);
    }
  }

  private void setNumericObject(int parameterIndex, Object parameterObj, int targetSqlType) throws SQLException {
    Number numberParam;
    if (parameterObj instanceof Boolean) {
      numberParam = (Boolean) parameterObj ? Integer.valueOf(1) : Integer.valueOf(0);
    } else if (parameterObj instanceof String) {
      switch (targetSqlType) {
        case Types.BIT:
          if ("1".equals(parameterObj) || "0".equals(parameterObj)) {
            numberParam = Integer.valueOf((String) parameterObj);
          } else {
            boolean parameterAsBoolean = "true".equalsIgnoreCase((String) parameterObj);
            numberParam = parameterAsBoolean ? Integer.valueOf(1) : Integer.valueOf(0);
          }
          break;

        case Types.TINYINT:
        case Types.SMALLINT:
        case Types.INTEGER:
          numberParam = Integer.valueOf((String) parameterObj);
          break;

        case Types.BIGINT:
          numberParam = Long.valueOf((String) parameterObj);
          break;

        case Types.REAL:
          numberParam = Float.valueOf((String) parameterObj);
          break;

        case Types.FLOAT:
        case Types.DOUBLE:
          numberParam = Double.valueOf((String) parameterObj);
          break;

        case Types.DECIMAL:
        case Types.NUMERIC:
        default:
          numberParam = new java.math.BigDecimal((String) parameterObj);
      }
    } else {
      numberParam = (Number) parameterObj;
    }
    switch (targetSqlType) {
      case Types.BIT:
      case Types.TINYINT:
      case Types.SMALLINT:
      case Types.INTEGER:
        setInt(parameterIndex, numberParam.intValue());
        break;

      case Types.BIGINT:
        setLong(parameterIndex, numberParam.longValue());
        break;

      case Types.REAL:
        setFloat(parameterIndex, numberParam.floatValue());
        break;

      case Types.FLOAT:
      case Types.DOUBLE:
        setDouble(parameterIndex, numberParam.doubleValue());
        break;

      case Types.DECIMAL:
      case Types.NUMERIC:

        if (numberParam instanceof java.math.BigDecimal bigDecimal) {
          setBigDecimal(parameterIndex, bigDecimal);
        } else if (numberParam instanceof java.math.BigInteger) {
          setObject(parameterIndex, numberParam); // TODO: We need to test serialization of these, I think it may not be right
        } else {
          setBigDecimal(parameterIndex, BigDecimal.valueOf(numberParam.doubleValue()));
        }
        break;
    }
  }

  /**
   * <p>Sets the value of the designated parameter using the given object.
   *
   * <p>The JDBC specification specifies a standard mapping from
   * Java {@code Object} types to SQL types.  The given argument
   * will be converted to the corresponding SQL type before being
   * sent to the database.
   *
   * <p>Note that this method may be used to pass database-
   * specific abstract data types, by using a driver-specific Java
   * type.
   * <p>
   * If the object is of a class implementing the interface {@code SQLData},
   * the JDBC driver should call the method {@code SQLData.writeSQL}
   * to write it to the SQL data stream.
   * If, on the other hand, the object is of a class implementing
   * {@code Ref}, {@code Blob}, {@code Clob},  {@code NClob},
   * {@code Struct}, {@code java.net.URL}, {@code RowId}, {@code SQLXML}
   * or {@code Array}, the driver should pass it to the database as a
   * value of the corresponding SQL type.
   * <p>
   * <b>Note:</b> Not all databases allow for a non-typed Null to be sent to
   * the backend. For maximum portability, the {@code setNull} or the
   * {@code setObject(int parameterIndex, Object x, int sqlType)}
   * method should be used
   * instead of {@code setObject(int parameterIndex, Object x)}.
   * <p>
   * <b>Note:</b> This method throws an exception if there is an ambiguity, for example, if the
   * object is of a class implementing more than one of the interfaces named above.
   *
   * @param parameterIndex the first parameter is 1, the second is 2, ...
   * @param x              the object containing the input parameter value
   * @throws SQLException if parameterIndex does not correspond to a parameter
   *                      marker in the SQL statement; if a database access error occurs;
   *                      this method is called on a closed {@code PreparedStatement}
   *                      or the type of the given object is ambiguous
   */
  @Override
  public void setObject(int parameterIndex, Object x) throws SQLException {
    checkOpen();
    int curSize = parameters.size();
    if (curSize < parameterIndex) {
      parameters.ensureCapacity(parameterIndex);
      for (int i = curSize; i < parameterIndex; i++) {
        parameters.add(null);
      }
    }
    parameters.set(parameterIndex-1, Parameter.unnamed(x));
  }

  /**
   * Executes the SQL statement in this {@code PreparedStatement} object,
   * which may be any kind of SQL statement.
   * Some prepared statements return multiple results; the {@code execute}
   * method handles these complex statements as well as the simpler
   * form of statements handled by the methods {@code executeQuery}
   * and {@code executeUpdate}.
   * <p>
   * The {@code execute} method returns a {@code boolean} to
   * indicate the form of the first result.  You must call either the method
   * {@code getResultSet} or {@code getUpdateCount}
   * to retrieve the result; you must call {@code getMoreResults} to
   * move to any subsequent result(s).
   *
   * @return {@code true} if the first result is a {@code ResultSet}
   * object; {@code false} if the first result is an update
   * count or there is no result
   * @throws SQLException        if a database access error occurs;
   *                             this method is called on a closed {@code PreparedStatement}
   *                             or an argument is supplied to this method
   * @throws SQLTimeoutException when the driver has determined that the
   *                             timeout value that was specified by the {@code setQueryTimeout}
   *                             method has been exceeded and has at least attempted to cancel
   *                             the currently running {@code Statement}
   * @see Statement#execute
   * @see Statement#getResultSet
   * @see Statement#getUpdateCount
   * @see Statement#getMoreResults
   */
  @Override
  public boolean execute() throws SQLException {
    checkOpen();
    checkSQLNullOrEmpty(sql);
    clearLastResults();
    ExecuteQueryRequestResults.Result requestResult = conn.request(com.rqlite.dto.Statement.newBuilder().setSql(sql).setParameters(parameters).build(), this);
    if (requestResult.columns == null) {
      lastUpdateCount = requestResult.rowsAffected;
      return false;
    } else {
      Result clone = new Result(); // Yuck
      clone.columns = requestResult.columns;
      clone.values = requestResult.values;
      clone.types = requestResult.types;
      clone.time = requestResult.time;
      clone.error = requestResult.error;
      lastResult = new RqliteResultSet(clone, this);
      return true;
    }
  }

  /**
   * Adds a set of parameters to this {@code PreparedStatement}
   * object's batch of commands.
   *
   * @throws SQLException if a database access error occurs or
   *                      this method is called on a closed {@code PreparedStatement}
   * @see Statement#addBatch
   * @since 1.2
   */
  @Override
  public void addBatch() throws SQLException {
    checkOpen();
    this.batch.add(new ArrayList<>(parameters));
    parameters.clear();
  }

  @Override
  public int[] executeBatch() throws SQLException {
    checkOpen();
    clearLastResults();
    try {
      return conn.executeBatch(batch.stream().map((p) -> com.rqlite.dto.Statement.newBuilder().setSql(sql).setParameters(p).build()).toList(), this);
    } finally {
      clearBatch();
    }
  }

  /**
   * Sets the designated parameter to the given {@code Reader}
   * object, which is the given number of characters long.
   * When a very large UNICODE value is input to a {@code LONGVARCHAR}
   * parameter, it may be more practical to send it via a
   * {@code java.io.Reader} object. The data will be read from the stream
   * as needed until end-of-file is reached.  The JDBC driver will
   * do any necessary conversion from UNICODE to the database char format.
   *
   * <P><B>Note:</B> This stream object can either be a standard
   * Java stream object or your own subclass that implements the
   * standard interface.
   *
   * @param parameterIndex the first parameter is 1, the second is 2, ...
   * @param reader         the {@code java.io.Reader} object that contains the
   *                       Unicode data
   * @param length         the number of characters in the stream
   * @throws SQLException if parameterIndex does not correspond to a parameter
   *                      marker in the SQL statement; if a database access error occurs or
   *                      this method is called on a closed {@code PreparedStatement}
   * @since 1.2
   */
  @Override
  public void setCharacterStream(int parameterIndex, Reader reader, int length) throws SQLException {
    throw new SQLFeatureNotSupportedException(RqliteResultSet.SQL_FEATURE_NOT_SUPPORTED);
  }

  /**
   * Sets the designated parameter to the given
   * {@code REF(<structured-type>)} value.
   * The driver converts this to an SQL {@code REF} value when it
   * sends it to the database.
   *
   * @param parameterIndex the first parameter is 1, the second is 2, ...
   * @param x              an SQL {@code REF} value
   * @throws SQLException                    if parameterIndex does not correspond to a parameter
   *                                         marker in the SQL statement; if a database access error occurs or
   *                                         this method is called on a closed {@code PreparedStatement}
   * @throws SQLFeatureNotSupportedException if the JDBC driver does not support this method
   * @since 1.2
   */
  @Override
  public void setRef(int parameterIndex, Ref x) throws SQLException {
    throw new SQLFeatureNotSupportedException(RqliteResultSet.SQL_FEATURE_NOT_SUPPORTED);
  }

  /**
   * Sets the designated parameter to the given {@code java.sql.Blob} object.
   * The driver converts this to an SQL {@code BLOB} value when it
   * sends it to the database.
   *
   * @param parameterIndex the first parameter is 1, the second is 2, ...
   * @param x              a {@code Blob} object that maps an SQL {@code BLOB} value
   * @throws SQLException                    if parameterIndex does not correspond to a parameter
   *                                         marker in the SQL statement; if a database access error occurs or
   *                                         this method is called on a closed {@code PreparedStatement}
   * @throws SQLFeatureNotSupportedException if the JDBC driver does not support this method
   * @since 1.2
   */
  @Override
  public void setBlob(int parameterIndex, Blob x) throws SQLException {
    throw new SQLFeatureNotSupportedException(RqliteResultSet.SQL_FEATURE_NOT_SUPPORTED);
  }

  /**
   * Sets the designated parameter to the given {@code java.sql.Clob} object.
   * The driver converts this to an SQL {@code CLOB} value when it
   * sends it to the database.
   *
   * @param parameterIndex the first parameter is 1, the second is 2, ...
   * @param x              a {@code Clob} object that maps an SQL {@code CLOB} value
   * @throws SQLException                    if parameterIndex does not correspond to a parameter
   *                                         marker in the SQL statement; if a database access error occurs or
   *                                         this method is called on a closed {@code PreparedStatement}
   * @throws SQLFeatureNotSupportedException if the JDBC driver does not support this method
   * @since 1.2
   */
  @Override
  public void setClob(int parameterIndex, Clob x) throws SQLException {
    checkOpen();
    if (x.length() > Integer.MAX_VALUE) {
      throw new SQLFeatureNotSupportedException("Clob lengths larger than max int are unsupported");
    }
    setObject(parameterIndex, x.getSubString(0, (int) x.length()));
  }

  /**
   * Sets the designated parameter to the given {@code java.sql.Array} object.
   * The driver converts this to an SQL {@code ARRAY} value when it
   * sends it to the database.
   *
   * @param parameterIndex the first parameter is 1, the second is 2, ...
   * @param x              an {@code Array} object that maps an SQL {@code ARRAY} value
   * @throws SQLException                    if parameterIndex does not correspond to a parameter
   *                                         marker in the SQL statement; if a database access error occurs or
   *                                         this method is called on a closed {@code PreparedStatement}
   * @throws SQLFeatureNotSupportedException if the JDBC driver does not support this method
   * @since 1.2
   */
  @Override
  public void setArray(int parameterIndex, Array x) throws SQLException {
    throw new SQLFeatureNotSupportedException(RqliteResultSet.SQL_FEATURE_NOT_SUPPORTED);
  }

  /**
   * Retrieves a {@code ResultSetMetaData} object that contains
   * information about the columns of the {@code ResultSet} object
   * that will be returned when this {@code PreparedStatement} object
   * is executed.
   * <p>
   * Because a {@code PreparedStatement} object is precompiled, it is
   * possible to know about the {@code ResultSet} object that it will
   * return without having to execute it.  Consequently, it is possible
   * to invoke the method {@code getMetaData} on a
   * {@code PreparedStatement} object rather than waiting to execute
   * it and then invoking the {@code ResultSet.getMetaData} method
   * on the {@code ResultSet} object that is returned.
   * <p>
   * <B>NOTE:</B> Using this method may be expensive for some drivers due
   * to the lack of underlying DBMS support.
   *
   * @return the description of a {@code ResultSet} object's columns or
   * {@code null} if the driver cannot return a
   * {@code ResultSetMetaData} object
   * @throws SQLException                    if a database access error occurs or
   *                                         this method is called on a closed {@code PreparedStatement}
   * @throws SQLFeatureNotSupportedException if the JDBC driver does not support
   *                                         this method
   * @since 1.2
   */
  @Override
  public ResultSetMetaData getMetaData() throws SQLException {
    throw new SQLFeatureNotSupportedException(RqliteResultSet.SQL_FEATURE_NOT_SUPPORTED);
  }

  /**
   * Sets the designated parameter to the given {@code java.sql.Date} value,
   * using the given {@code Calendar} object.  The driver uses
   * the {@code Calendar} object to construct an SQL {@code DATE} value,
   * which the driver then sends to the database.  With
   * a {@code Calendar} object, the driver can calculate the date
   * taking into account a custom timezone.  If no
   * {@code Calendar} object is specified, the driver uses the default
   * timezone, which is that of the virtual machine running the application.
   *
   * @param parameterIndex the first parameter is 1, the second is 2, ...
   * @param x              the parameter value
   * @param cal            the {@code Calendar} object the driver will use
   *                       to construct the date
   * @throws SQLException if parameterIndex does not correspond to a parameter
   *                      marker in the SQL statement; if a database access error occurs or
   *                      this method is called on a closed {@code PreparedStatement}
   * @since 1.2
   */
  @Override
  public void setDate(int parameterIndex, Date x, Calendar cal) throws SQLException {
    setDate(parameterIndex, x); // I don't think the calendar would influence this in our format
  }

  /**
   * Sets the designated parameter to the given {@code java.sql.Time} value,
   * using the given {@code Calendar} object.  The driver uses
   * the {@code Calendar} object to construct an SQL {@code TIME} value,
   * which the driver then sends to the database.  With
   * a {@code Calendar} object, the driver can calculate the time
   * taking into account a custom timezone.  If no
   * {@code Calendar} object is specified, the driver uses the default
   * timezone, which is that of the virtual machine running the application.
   *
   * @param parameterIndex the first parameter is 1, the second is 2, ...
   * @param x              the parameter value
   * @param cal            the {@code Calendar} object the driver will use
   *                       to construct the time
   * @throws SQLException if parameterIndex does not correspond to a parameter
   *                      marker in the SQL statement; if a database access error occurs or
   *                      this method is called on a closed {@code PreparedStatement}
   * @since 1.2
   */
  @Override
  public void setTime(int parameterIndex, Time x, Calendar cal) throws SQLException {
    setTime(parameterIndex, x);
  }

  /**
   * Sets the designated parameter to the given {@code java.sql.Timestamp} value,
   * using the given {@code Calendar} object.  The driver uses
   * the {@code Calendar} object to construct an SQL {@code TIMESTAMP} value,
   * which the driver then sends to the database.  With a
   * {@code Calendar} object, the driver can calculate the timestamp
   * taking into account a custom timezone.  If no
   * {@code Calendar} object is specified, the driver uses the default
   * timezone, which is that of the virtual machine running the application.
   *
   * @param parameterIndex the first parameter is 1, the second is 2, ...
   * @param x              the parameter value
   * @param cal            the {@code Calendar} object the driver will use
   *                       to construct the timestamp
   * @throws SQLException if parameterIndex does not correspond to a parameter
   *                      marker in the SQL statement; if a database access error occurs or
   *                      this method is called on a closed {@code PreparedStatement}
   * @since 1.2
   */
  @Override
  public void setTimestamp(int parameterIndex, Timestamp x, Calendar cal) throws SQLException {
    if (cal == null) {
      cal = Calendar.getInstance();
    }
    setObject(parameterIndex, TIMESTAMP_FORMATTER.format(ZonedDateTime.ofInstant(x.toInstant(), cal.getTimeZone().toZoneId())));
  }

  /**
   * Sets the designated parameter to SQL {@code NULL}.
   * This version of the method {@code setNull} should
   * be used for user-defined types and REF type parameters.  Examples
   * of user-defined types include: STRUCT, DISTINCT, JAVA_OBJECT, and
   * named array types.
   *
   * <P><B>Note:</B> To be portable, applications must give the
   * SQL type code and the fully-qualified SQL type name when specifying
   * a NULL user-defined or REF parameter.  In the case of a user-defined type
   * the name is the type name of the parameter itself.  For a REF
   * parameter, the name is the type name of the referenced type.  If
   * a JDBC driver does not need the type code or type name information,
   * it may ignore it.
   * <p>
   * Although it is intended for user-defined and Ref parameters,
   * this method may be used to set a null parameter of any JDBC type.
   * If the parameter does not have a user-defined or REF type, the given
   * typeName is ignored.
   *
   * @param parameterIndex the first parameter is 1, the second is 2, ...
   * @param sqlType        a value from {@code java.sql.Types}
   * @param typeName       the fully-qualified name of an SQL user-defined type;
   *                       ignored if the parameter is not a user-defined type or REF
   * @throws SQLException                    if parameterIndex does not correspond to a parameter
   *                                         marker in the SQL statement; if a database access error occurs or
   *                                         this method is called on a closed {@code PreparedStatement}
   * @throws SQLFeatureNotSupportedException if {@code sqlType} is
   *                                         a {@code ARRAY}, {@code BLOB}, {@code CLOB},
   *                                         {@code DATALINK}, {@code JAVA_OBJECT}, {@code NCHAR},
   *                                         {@code NCLOB}, {@code NVARCHAR}, {@code LONGNVARCHAR},
   *                                         {@code REF}, {@code ROWID}, {@code SQLXML}
   *                                         or  {@code STRUCT} data type and the JDBC driver does not support
   *                                         this data type or if the JDBC driver does not support this method
   * @since 1.2
   */
  @Override
  public void setNull(int parameterIndex, int sqlType, String typeName) throws SQLException {
    setNull(parameterIndex, sqlType);
  }

  /**
   * Sets the designated parameter to the given {@code java.net.URL} value.
   * The driver converts this to an SQL {@code DATALINK} value
   * when it sends it to the database.
   *
   * @param parameterIndex the first parameter is 1, the second is 2, ...
   * @param x              the {@code java.net.URL} object to be set
   * @throws SQLException                    if parameterIndex does not correspond to a parameter
   *                                         marker in the SQL statement; if a database access error occurs or
   *                                         this method is called on a closed {@code PreparedStatement}
   * @throws SQLFeatureNotSupportedException if the JDBC driver does not support this method
   * @since 1.4
   */
  @Override
  public void setURL(int parameterIndex, URL x) throws SQLException {
    throw new SQLFeatureNotSupportedException(RqliteResultSet.SQL_FEATURE_NOT_SUPPORTED);
  }

  /**
   * Retrieves the number, types and properties of this
   * {@code PreparedStatement} object's parameters.
   *
   * @return a {@code ParameterMetaData} object that contains information
   * about the number, types and properties for each
   * parameter marker of this {@code PreparedStatement} object
   * @throws SQLException if a database access error occurs or
   *                      this method is called on a closed {@code PreparedStatement}
   * @see ParameterMetaData
   * @since 1.4
   */
  @Override
  public ParameterMetaData getParameterMetaData() throws SQLException {
    return new RqliteParameterMetaData(parameters);
  }

  /**
   * Sets the designated parameter to the given {@code java.sql.RowId} object. The
   * driver converts this to a SQL {@code ROWID} value when it sends it
   * to the database
   *
   * @param parameterIndex the first parameter is 1, the second is 2, ...
   * @param x              the parameter value
   * @throws SQLException                    if parameterIndex does not correspond to a parameter
   *                                         marker in the SQL statement; if a database access error occurs or
   *                                         this method is called on a closed {@code PreparedStatement}
   * @throws SQLFeatureNotSupportedException if the JDBC driver does not support this method
   * @since 1.6
   */
  @Override
  public void setRowId(int parameterIndex, RowId x) throws SQLException {
    throw new SQLFeatureNotSupportedException(RqliteResultSet.SQL_FEATURE_NOT_SUPPORTED);
  }

  /**
   * Sets the designated parameter to the given {@code String} object.
   * The driver converts this to a SQL {@code NCHAR} or
   * {@code NVARCHAR} or {@code LONGNVARCHAR} value
   * (depending on the argument's
   * size relative to the driver's limits on {@code NVARCHAR} values)
   * when it sends it to the database.
   *
   * @param parameterIndex of the first parameter is 1, the second is 2, ...
   * @param value          the parameter value
   * @throws SQLException                    if parameterIndex does not correspond to a parameter
   *                                         marker in the SQL statement; if the driver does not support national
   *                                         character sets;  if the driver can detect that a data conversion
   *                                         error could occur; if a database access error occurs; or
   *                                         this method is called on a closed {@code PreparedStatement}
   * @throws SQLFeatureNotSupportedException if the JDBC driver does not support this method
   * @since 1.6
   */
  @Override
  public void setNString(int parameterIndex, String value) throws SQLException {
    throw new SQLFeatureNotSupportedException(RqliteResultSet.SQL_FEATURE_NOT_SUPPORTED);
  }

  /**
   * Sets the designated parameter to a {@code Reader} object. The
   * {@code Reader} reads the data till end-of-file is reached. The
   * driver does the necessary conversion from Java character format to
   * the national character set in the database.
   *
   * @param parameterIndex of the first parameter is 1, the second is 2, ...
   * @param value          the parameter value
   * @param length         the number of characters in the parameter data.
   * @throws SQLException                    if parameterIndex does not correspond to a parameter
   *                                         marker in the SQL statement; if the driver does not support national
   *                                         character sets;  if the driver can detect that a data conversion
   *                                         error could occur; if a database access error occurs; or
   *                                         this method is called on a closed {@code PreparedStatement}
   * @throws SQLFeatureNotSupportedException if the JDBC driver does not support this method
   * @since 1.6
   */
  @Override
  public void setNCharacterStream(int parameterIndex, Reader value, long length) throws SQLException {
    throw new SQLFeatureNotSupportedException(RqliteResultSet.SQL_FEATURE_NOT_SUPPORTED);
  }

  /**
   * Sets the designated parameter to a {@code java.sql.NClob} object. The driver converts this to a
   * SQL {@code NCLOB} value when it sends it to the database.
   *
   * @param parameterIndex of the first parameter is 1, the second is 2, ...
   * @param value          the parameter value
   * @throws SQLException                    if parameterIndex does not correspond to a parameter
   *                                         marker in the SQL statement; if the driver does not support national
   *                                         character sets;  if the driver can detect that a data conversion
   *                                         error could occur; if a database access error occurs; or
   *                                         this method is called on a closed {@code PreparedStatement}
   * @throws SQLFeatureNotSupportedException if the JDBC driver does not support this method
   * @since 1.6
   */
  @Override
  public void setNClob(int parameterIndex, NClob value) throws SQLException {
    throw new SQLFeatureNotSupportedException(RqliteResultSet.SQL_FEATURE_NOT_SUPPORTED);
  }

  /**
   * Sets the designated parameter to a {@code Reader} object.  The reader must contain  the number
   * of characters specified by length otherwise a {@code SQLException} will be
   * generated when the {@code PreparedStatement} is executed.
   * This method differs from the {@code setCharacterStream (int, Reader, int)} method
   * because it informs the driver that the parameter value should be sent to
   * the server as a {@code CLOB}.  When the {@code setCharacterStream} method is used, the
   * driver may have to do extra work to determine whether the parameter
   * data should be sent to the server as a {@code LONGVARCHAR} or a {@code CLOB}
   *
   * @param parameterIndex index of the first parameter is 1, the second is 2, ...
   * @param reader         An object that contains the data to set the parameter value to.
   * @param length         the number of characters in the parameter data.
   * @throws SQLException                    if parameterIndex does not correspond to a parameter
   *                                         marker in the SQL statement; if a database access error occurs; this method is called on
   *                                         a closed {@code PreparedStatement} or if the length specified is less than zero.
   * @throws SQLFeatureNotSupportedException if the JDBC driver does not support this method
   * @since 1.6
   */
  @Override
  public void setClob(int parameterIndex, Reader reader, long length) throws SQLException {
    throw new SQLFeatureNotSupportedException(RqliteResultSet.SQL_FEATURE_NOT_SUPPORTED);
  }

  /**
   * Sets the designated parameter to a {@code InputStream} object.
   * The {@code Inputstream} must contain  the number
   * of characters specified by length otherwise a {@code SQLException} will be
   * generated when the {@code PreparedStatement} is executed.
   * This method differs from the {@code setBinaryStream (int, InputStream, int)}
   * method because it informs the driver that the parameter value should be
   * sent to the server as a {@code BLOB}.  When the {@code setBinaryStream} method is used,
   * the driver may have to do extra work to determine whether the parameter
   * data should be sent to the server as a {@code LONGVARBINARY} or a {@code BLOB}
   *
   * @param parameterIndex index of the first parameter is 1,
   *                       the second is 2, ...
   * @param inputStream    An object that contains the data to set the parameter
   *                       value to.
   * @param length         the number of bytes in the parameter data.
   * @throws SQLException                    if parameterIndex does not correspond to a parameter
   *                                         marker in the SQL statement; if a database access error occurs;
   *                                         this method is called on a closed {@code PreparedStatement};
   *                                         if the length specified
   *                                         is less than zero or if the number of bytes in the {@code InputStream} does not match
   *                                         the specified length.
   * @throws SQLFeatureNotSupportedException if the JDBC driver does not support this method
   * @since 1.6
   */
  @Override
  public void setBlob(int parameterIndex, InputStream inputStream, long length) throws SQLException {
    throw new SQLFeatureNotSupportedException(RqliteResultSet.SQL_FEATURE_NOT_SUPPORTED);
  }

  /**
   * Sets the designated parameter to a {@code Reader} object.  The reader must contain  the number
   * of characters specified by length otherwise a {@code SQLException} will be
   * generated when the {@code PreparedStatement} is executed.
   * This method differs from the {@code setCharacterStream (int, Reader, int)} method
   * because it informs the driver that the parameter value should be sent to
   * the server as a {@code NCLOB}.  When the {@code setCharacterStream} method is used, the
   * driver may have to do extra work to determine whether the parameter
   * data should be sent to the server as a {@code LONGNVARCHAR} or a {@code NCLOB}
   *
   * @param parameterIndex index of the first parameter is 1, the second is 2, ...
   * @param reader         An object that contains the data to set the parameter value to.
   * @param length         the number of characters in the parameter data.
   * @throws SQLException                    if parameterIndex does not correspond to a parameter
   *                                         marker in the SQL statement; if the length specified is less than zero;
   *                                         if the driver does not support national character sets;
   *                                         if the driver can detect that a data conversion
   *                                         error could occur;  if a database access error occurs or
   *                                         this method is called on a closed {@code PreparedStatement}
   * @throws SQLFeatureNotSupportedException if the JDBC driver does not support this method
   * @since 1.6
   */
  @Override
  public void setNClob(int parameterIndex, Reader reader, long length) throws SQLException {
    throw new SQLFeatureNotSupportedException(RqliteResultSet.SQL_FEATURE_NOT_SUPPORTED);
  }

  /**
   * Sets the designated parameter to the given {@code java.sql.SQLXML} object.
   * The driver converts this to an
   * SQL {@code XML} value when it sends it to the database.
   *
   * @param parameterIndex index of the first parameter is 1, the second is 2, ...
   * @param xmlObject      a {@code SQLXML} object that maps an SQL {@code XML} value
   * @throws SQLException                    if parameterIndex does not correspond to a parameter
   *                                         marker in the SQL statement; if a database access error occurs;
   *                                         this method is called on a closed {@code PreparedStatement}
   *                                         or the {@code java.xml.transform.Result},
   *                                         {@code Writer} or {@code OutputStream} has not been closed for
   *                                         the {@code SQLXML} object
   * @throws SQLFeatureNotSupportedException if the JDBC driver does not support this method
   * @since 1.6
   */
  @Override
  public void setSQLXML(int parameterIndex, SQLXML xmlObject) throws SQLException {
    throw new SQLFeatureNotSupportedException(RqliteResultSet.SQL_FEATURE_NOT_SUPPORTED);
  }

  /**
   * <p>Sets the value of the designated parameter with the given object.
   * <p>
   * If the second argument is an {@code InputStream} then the stream must contain
   * the number of bytes specified by scaleOrLength.  If the second argument is a
   * {@code Reader} then the reader must contain the number of characters specified
   * by scaleOrLength. If these conditions are not true the driver will generate a
   * {@code SQLException} when the prepared statement is executed.
   *
   * <p>The given Java object will be converted to the given targetSqlType
   * before being sent to the database.
   * <p>
   * If the object has a custom mapping (is of a class implementing the
   * interface {@code SQLData}),
   * the JDBC driver should call the method {@code SQLData.writeSQL} to
   * write it to the SQL data stream.
   * If, on the other hand, the object is of a class implementing
   * {@code Ref}, {@code Blob}, {@code Clob},  {@code NClob},
   * {@code Struct}, {@code java.net.URL},
   * or {@code Array}, the driver should pass it to the database as a
   * value of the corresponding SQL type.
   *
   * <p>Note that this method may be used to pass database-specific
   * abstract data types.
   *
   * @param parameterIndex the first parameter is 1, the second is 2, ...
   * @param x              the object containing the input parameter value
   * @param targetSqlType  the SQL type (as defined in java.sql.Types) to be
   *                       sent to the database. The scale argument may further qualify this type.
   * @param scaleOrLength  for {@code java.sql.Types.DECIMAL}
   *                       or {@code java.sql.Types.NUMERIC types},
   *                       this is the number of digits after the decimal point. For
   *                       Java Object types {@code InputStream} and {@code Reader},
   *                       this is the length
   *                       of the data in the stream or reader.  For all other types,
   *                       this value will be ignored.
   * @throws SQLException                    if parameterIndex does not correspond to a parameter
   *                                         marker in the SQL statement; if a database access error occurs;
   *                                         this method is called on a closed {@code PreparedStatement} or
   *                                         if the Java Object specified by x is an InputStream
   *                                         or Reader object and the value of the scale parameter is less
   *                                         than zero
   * @throws SQLFeatureNotSupportedException if
   *                                         the JDBC driver does not support the specified targetSqlType
   * @see Types
   */
  @Override
  public void setObject(int parameterIndex, Object x, int targetSqlType, int scaleOrLength) throws SQLException {
    setObject(parameterIndex, x, targetSqlType);
  }

  /**
   * Sets the designated parameter to the given input stream, which will have
   * the specified number of bytes.
   * When a very large ASCII value is input to a {@code LONGVARCHAR}
   * parameter, it may be more practical to send it via a
   * {@code java.io.InputStream}. Data will be read from the stream
   * as needed until end-of-file is reached.  The JDBC driver will
   * do any necessary conversion from ASCII to the database char format.
   *
   * <P><B>Note:</B> This stream object can either be a standard
   * Java stream object or your own subclass that implements the
   * standard interface.
   *
   * @param parameterIndex the first parameter is 1, the second is 2, ...
   * @param x              the Java input stream that contains the ASCII parameter value
   * @param length         the number of bytes in the stream
   * @throws SQLException if parameterIndex does not correspond to a parameter
   *                      marker in the SQL statement; if a database access error occurs or
   *                      this method is called on a closed {@code PreparedStatement}
   * @since 1.6
   */
  @Override
  public void setAsciiStream(int parameterIndex, InputStream x, long length) throws SQLException {
    throw new SQLFeatureNotSupportedException(RqliteResultSet.SQL_FEATURE_NOT_SUPPORTED);
  }

  /**
   * Sets the designated parameter to the given input stream, which will have
   * the specified number of bytes.
   * When a very large binary value is input to a {@code LONGVARBINARY}
   * parameter, it may be more practical to send it via a
   * {@code java.io.InputStream} object. The data will be read from the
   * stream as needed until end-of-file is reached.
   *
   * <P><B>Note:</B> This stream object can either be a standard
   * Java stream object or your own subclass that implements the
   * standard interface.
   *
   * @param parameterIndex the first parameter is 1, the second is 2, ...
   * @param x              the java input stream which contains the binary parameter value
   * @param length         the number of bytes in the stream
   * @throws SQLException if parameterIndex does not correspond to a parameter
   *                      marker in the SQL statement; if a database access error occurs or
   *                      this method is called on a closed {@code PreparedStatement}
   * @since 1.6
   */
  @Override
  public void setBinaryStream(int parameterIndex, InputStream x, long length) throws SQLException {
    throw new SQLFeatureNotSupportedException(RqliteResultSet.SQL_FEATURE_NOT_SUPPORTED);
  }

  /**
   * Sets the designated parameter to the given {@code Reader}
   * object, which is the given number of characters long.
   * When a very large UNICODE value is input to a {@code LONGVARCHAR}
   * parameter, it may be more practical to send it via a
   * {@code java.io.Reader} object. The data will be read from the stream
   * as needed until end-of-file is reached.  The JDBC driver will
   * do any necessary conversion from UNICODE to the database char format.
   *
   * <P><B>Note:</B> This stream object can either be a standard
   * Java stream object or your own subclass that implements the
   * standard interface.
   *
   * @param parameterIndex the first parameter is 1, the second is 2, ...
   * @param reader         the {@code java.io.Reader} object that contains the
   *                       Unicode data
   * @param length         the number of characters in the stream
   * @throws SQLException if parameterIndex does not correspond to a parameter
   *                      marker in the SQL statement; if a database access error occurs or
   *                      this method is called on a closed {@code PreparedStatement}
   * @since 1.6
   */
  @Override
  public void setCharacterStream(int parameterIndex, Reader reader, long length) throws SQLException {
    throw new SQLFeatureNotSupportedException(RqliteResultSet.SQL_FEATURE_NOT_SUPPORTED);
  }

  /**
   * Sets the designated parameter to the given input stream.
   * When a very large ASCII value is input to a {@code LONGVARCHAR}
   * parameter, it may be more practical to send it via a
   * {@code java.io.InputStream}. Data will be read from the stream
   * as needed until end-of-file is reached.  The JDBC driver will
   * do any necessary conversion from ASCII to the database char format.
   *
   * <P><B>Note:</B> This stream object can either be a standard
   * Java stream object or your own subclass that implements the
   * standard interface.
   * <P><B>Note:</B> Consult your JDBC driver documentation to determine if
   * it might be more efficient to use a version of
   * {@code setAsciiStream} which takes a length parameter.
   *
   * @param parameterIndex the first parameter is 1, the second is 2, ...
   * @param x              the Java input stream that contains the ASCII parameter value
   * @throws SQLException                    if parameterIndex does not correspond to a parameter
   *                                         marker in the SQL statement; if a database access error occurs or
   *                                         this method is called on a closed {@code PreparedStatement}
   * @throws SQLFeatureNotSupportedException if the JDBC driver does not support this method
   * @since 1.6
   */
  @Override
  public void setAsciiStream(int parameterIndex, InputStream x) throws SQLException {
    throw new SQLFeatureNotSupportedException(RqliteResultSet.SQL_FEATURE_NOT_SUPPORTED);
  }

  /**
   * Sets the designated parameter to the given input stream.
   * When a very large binary value is input to a {@code LONGVARBINARY}
   * parameter, it may be more practical to send it via a
   * {@code java.io.InputStream} object. The data will be read from the
   * stream as needed until end-of-file is reached.
   *
   * <P><B>Note:</B> This stream object can either be a standard
   * Java stream object or your own subclass that implements the
   * standard interface.
   * <P><B>Note:</B> Consult your JDBC driver documentation to determine if
   * it might be more efficient to use a version of
   * {@code setBinaryStream} which takes a length parameter.
   *
   * @param parameterIndex the first parameter is 1, the second is 2, ...
   * @param x              the java input stream which contains the binary parameter value
   * @throws SQLException                    if parameterIndex does not correspond to a parameter
   *                                         marker in the SQL statement; if a database access error occurs or
   *                                         this method is called on a closed {@code PreparedStatement}
   * @throws SQLFeatureNotSupportedException if the JDBC driver does not support this method
   * @since 1.6
   */
  @Override
  public void setBinaryStream(int parameterIndex, InputStream x) throws SQLException {
    throw new SQLFeatureNotSupportedException(RqliteResultSet.SQL_FEATURE_NOT_SUPPORTED);
  }

  /**
   * Sets the designated parameter to the given {@code Reader}
   * object.
   * When a very large UNICODE value is input to a {@code LONGVARCHAR}
   * parameter, it may be more practical to send it via a
   * {@code java.io.Reader} object. The data will be read from the stream
   * as needed until end-of-file is reached.  The JDBC driver will
   * do any necessary conversion from UNICODE to the database char format.
   *
   * <P><B>Note:</B> This stream object can either be a standard
   * Java stream object or your own subclass that implements the
   * standard interface.
   * <P><B>Note:</B> Consult your JDBC driver documentation to determine if
   * it might be more efficient to use a version of
   * {@code setCharacterStream} which takes a length parameter.
   *
   * @param parameterIndex the first parameter is 1, the second is 2, ...
   * @param reader         the {@code java.io.Reader} object that contains the
   *                       Unicode data
   * @throws SQLException                    if parameterIndex does not correspond to a parameter
   *                                         marker in the SQL statement; if a database access error occurs or
   *                                         this method is called on a closed {@code PreparedStatement}
   * @throws SQLFeatureNotSupportedException if the JDBC driver does not support this method
   * @since 1.6
   */
  @Override
  public void setCharacterStream(int parameterIndex, Reader reader) throws SQLException {
    throw new SQLFeatureNotSupportedException(RqliteResultSet.SQL_FEATURE_NOT_SUPPORTED);
  }

  /**
   * Sets the designated parameter to a {@code Reader} object. The
   * {@code Reader} reads the data till end-of-file is reached. The
   * driver does the necessary conversion from Java character format to
   * the national character set in the database.
   *
   * <P><B>Note:</B> This stream object can either be a standard
   * Java stream object or your own subclass that implements the
   * standard interface.
   * <P><B>Note:</B> Consult your JDBC driver documentation to determine if
   * it might be more efficient to use a version of
   * {@code setNCharacterStream} which takes a length parameter.
   *
   * @param parameterIndex of the first parameter is 1, the second is 2, ...
   * @param value          the parameter value
   * @throws SQLException                    if parameterIndex does not correspond to a parameter
   *                                         marker in the SQL statement; if the driver does not support national
   *                                         character sets;  if the driver can detect that a data conversion
   *                                         error could occur; if a database access error occurs; or
   *                                         this method is called on a closed {@code PreparedStatement}
   * @throws SQLFeatureNotSupportedException if the JDBC driver does not support this method
   * @since 1.6
   */
  @Override
  public void setNCharacterStream(int parameterIndex, Reader value) throws SQLException {
    throw new SQLFeatureNotSupportedException(RqliteResultSet.SQL_FEATURE_NOT_SUPPORTED);
  }

  /**
   * Sets the designated parameter to a {@code Reader} object.
   * This method differs from the {@code setCharacterStream (int, Reader)} method
   * because it informs the driver that the parameter value should be sent to
   * the server as a {@code CLOB}.  When the {@code setCharacterStream} method is used, the
   * driver may have to do extra work to determine whether the parameter
   * data should be sent to the server as a {@code LONGVARCHAR} or a {@code CLOB}
   *
   * <P><B>Note:</B> Consult your JDBC driver documentation to determine if
   * it might be more efficient to use a version of
   * {@code setClob} which takes a length parameter.
   *
   * @param parameterIndex index of the first parameter is 1, the second is 2, ...
   * @param reader         An object that contains the data to set the parameter value to.
   * @throws SQLException                    if parameterIndex does not correspond to a parameter
   *                                         marker in the SQL statement; if a database access error occurs; this method is called on
   *                                         a closed {@code PreparedStatement}or if parameterIndex does not correspond to a parameter
   *                                         marker in the SQL statement
   * @throws SQLFeatureNotSupportedException if the JDBC driver does not support this method
   * @since 1.6
   */
  @Override
  public void setClob(int parameterIndex, Reader reader) throws SQLException {
    throw new SQLFeatureNotSupportedException(RqliteResultSet.SQL_FEATURE_NOT_SUPPORTED);
  }

  /**
   * Sets the designated parameter to a {@code InputStream} object.
   * This method differs from the {@code setBinaryStream (int, InputStream)}
   * method because it informs the driver that the parameter value should be
   * sent to the server as a {@code BLOB}.  When the {@code setBinaryStream} method is used,
   * the driver may have to do extra work to determine whether the parameter
   * data should be sent to the server as a {@code LONGVARBINARY} or a {@code BLOB}
   *
   * <P><B>Note:</B> Consult your JDBC driver documentation to determine if
   * it might be more efficient to use a version of
   * {@code setBlob} which takes a length parameter.
   *
   * @param parameterIndex index of the first parameter is 1,
   *                       the second is 2, ...
   * @param inputStream    An object that contains the data to set the parameter
   *                       value to.
   * @throws SQLException                    if parameterIndex does not correspond to a parameter
   *                                         marker in the SQL statement; if a database access error occurs;
   *                                         this method is called on a closed {@code PreparedStatement} or
   *                                         if parameterIndex does not correspond
   *                                         to a parameter marker in the SQL statement,
   * @throws SQLFeatureNotSupportedException if the JDBC driver does not support this method
   * @since 1.6
   */
  @Override
  public void setBlob(int parameterIndex, InputStream inputStream) throws SQLException {
    throw new SQLFeatureNotSupportedException(RqliteResultSet.SQL_FEATURE_NOT_SUPPORTED);
  }

  /**
   * Sets the designated parameter to a {@code Reader} object.
   * This method differs from the {@code setCharacterStream (int, Reader)} method
   * because it informs the driver that the parameter value should be sent to
   * the server as a {@code NCLOB}.  When the {@code setCharacterStream} method is used, the
   * driver may have to do extra work to determine whether the parameter
   * data should be sent to the server as a {@code LONGNVARCHAR} or a {@code NCLOB}
   * <P><B>Note:</B> Consult your JDBC driver documentation to determine if
   * it might be more efficient to use a version of
   * {@code setNClob} which takes a length parameter.
   *
   * @param parameterIndex index of the first parameter is 1, the second is 2, ...
   * @param reader         An object that contains the data to set the parameter value to.
   * @throws SQLException                    if parameterIndex does not correspond to a parameter
   *                                         marker in the SQL statement;
   *                                         if the driver does not support national character sets;
   *                                         if the driver can detect that a data conversion
   *                                         error could occur;  if a database access error occurs or
   *                                         this method is called on a closed {@code PreparedStatement}
   * @throws SQLFeatureNotSupportedException if the JDBC driver does not support this method
   * @since 1.6
   */
  @Override
  public void setNClob(int parameterIndex, Reader reader) throws SQLException {
    throw new SQLFeatureNotSupportedException(RqliteResultSet.SQL_FEATURE_NOT_SUPPORTED);
  }

  public ResultSet executeQuery(String sql) throws SQLException {
    throw new SQLException("Method not allowed");
  }

  public int executeUpdate(String sql, int autoGeneratedKeys) throws SQLException {
    throw new SQLException("Method not allowed");
  }

  public boolean execute(String sql, int autoGeneratedKeys) throws SQLException {
    throw new SQLException("Method not allowed");
  }

  public void addBatch(String sql) throws SQLException {
    throw new SQLException("Method not allowed");
  }
}
